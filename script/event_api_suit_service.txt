def get_test_suit_by_plan_id(plan_id: int):
    """
    1、根据测试计划获取测试用例id列表
    2、根据测试用例id列表获取测试套件
    :param plan_id:
    :return: 测试套件列表 or 数据异常为None
    """
    # 根据测试计划获取测试用例列表
    case_id_list = [
        id.get("id")
        # 循环queryset字典列表
        for id in domain.QaCase.objects
            .values("id")
            .filter(id=plan_id, is_status=1, is_delete=0)
            .order_by('-sort').order_by('id')
    ]
    return _get_test_suit_by_case_id_list(case_id_list)


def case_id_list_by_plan_id(plan_id: int):
    """
    1、根据测试计划获取测试用例id列表
    2、根据测试用例id列表获取测试套件
    :param plan_id:
    :return: 测试套件列表 or 数据异常为None
    """
    # 根据测试计划获取测试用例列表
    return [
        id.get("id")
        # 循环queryset字典列表
        for id in domain.QaCase.objects
            .values("id")
            .filter(id=plan_id, is_status=1, is_delete=0)
            .order_by('-sort').order_by('id')
    ]


def get_test_suit_by_case_id(case_id: int):
    """
    根据测试用例id列表获取测试套件
    :param case_id:
    :return: 测试套件列表 or 数据异常为None
    """
    return _get_test_suit_by_case_id_list(
        [case_id]
    )


def _get_test_suit_by_case_id_list(case_id_list: list):
    """
    根据用例id的列表获取测试套件
    :return: 测试套件列表 or 数据异常为None
    业务逻辑
    目的：获取列表的测试套件（执行任务根据套件顺序执行）
    用例模型 关系与概念：
        一个业务流程存在多个接口，并且接口之间有执行顺序与参数依赖关系
        数据驱动设计：
            用例 = 模型 + 数据
            模型：定义了接口之间的执行顺序与配置，由多个接口节点构成
            数据：数据会注入到模型之中，对对应模型的节点进行替换操作，从而完成类似数据驱动的思想
            总结：一个用例一个模型，但可以拥有多组数据
    1、根据用例id，获取用例模型（多个节点）
    2、循环每个模型节点，进行数据补全
    3、拷贝模型，数据节点根据关联关系找到对应模型节点的索引 替换节点
    4、校验每个用例的数据，校验失败返回None
    5、校验成功，将 用例对象 装进测试套件
    """
    # 测试套件：deque
    test_suit = dto.TestSuitForDeque()

    for case_id in case_id_list:
        # 这个是临时的list，为了方便数据注入替换对应的
        case_model = []
        # 这个是节点的id列表，为了让数据替换对应的index
        test_case_order_list = [
            query_set_dict_list.get("id")
            for query_set_dict_list in domain.ApiCaseModel.objects
                .values("id")
                .filter(case_id=case_id, is_status=1, is_delete=0)
                .order_by('-sort').order_by('id')
        ]

        # 补全模型节点的数据
        # 将模型节点按顺序添加进入列表，成为一个临时存储的完全模型
        for test_case_node in query_set_list_serializers(
            domain.ApiCaseModel.objects
                .filter(case_id=case_id, is_status=1, is_delete=0)
                .order_by('-sort').order_by('id')
        ):
            # 补全模型需要关联的数据
            case_model.append(
                _make_case_node_to_complete(test_case_node)
            )

        # 获取用例数据列表
        # 拷贝模型列表 并替换拷贝后的列表 装进测试套件中
        for case_data in domain.ApiCaseData.objects \
            .values("id") \
            .filter(
            case_id=case_id, is_status=1, is_delete=0
        ):
            # 深拷贝
            case_model_with_data = copy.deepcopy(case_model)

            # 数据节点与模型节点替
            for case_data_node in query_set_list_serializers(
                domain.ApiCaseDataNode.objects
                    .filter(data_id=case_data.get("id"), is_status=1, is_delete=0)
            ):
                # 模型执行顺序的id列表，找到要替换的index
                serch_index = test_case_order_list.index(
                    case_data_node.get("model_id")
                )
                # 将模型对应节点替换成数据
                case_model_with_data[serch_index] = {**case_model_with_data[serch_index], **case_data_node}
            # 校验所有用例节点
            if _case_validate(case_model_with_data) is False:
                return None
            test_suit.append(case_model_with_data)
    return test_suit


def _make_case_node_to_complete(test_case_node: dict):
    """
    补全用例模型中的节点
    :return: TestSuitNode or None
    """
    # 补全接口信息
    api_info = domain.Api.objects.values(
        'api_name', 'method', 'path', 'content_type'
    ).get(
        id=test_case_node.get('api_id'), is_status=1, is_delete=0
    )

    # 补全校验点
    test_case_node['assert_list'] = list(
        domain.ApiAssert.objects.values(
            'api_model_id', 'assert_object', 'assert_method', 'assert_value'
        ).filter(
            api_model_id=test_case_node.get('id'), is_status=1, is_delete=0
        )
    )
    return {**api_info, **test_case_node}


def _case_validate(case_model_with_data: list):
    """
    校验模型每一个节点
    :param case_model_with_data:
    :return:
    """

    for i in range(len(case_model_with_data)):
        try:
            case_model_with_data[i] = dto.CaseApiNode(**case_model_with_data[i])
        except ValidationError as e:
            runner_log.error(e.json())
            return False
    return case_model_with_data
